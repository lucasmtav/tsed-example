"use strict";
var PassportMiddleware_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.PassportMiddleware = void 0;
const tslib_1 = require("tslib");
const common_1 = require("@tsed/common");
const core_1 = require("@tsed/core");
const exceptions_1 = require("@tsed/exceptions");
const passport_1 = tslib_1.__importDefault(require("passport"));
const PassportException_1 = require("../errors/PassportException");
const ProtocolsService_1 = require("../services/ProtocolsService");
const getProtocolsFromRequest_1 = require("../utils/getProtocolsFromRequest");
let PassportMiddleware = PassportMiddleware_1 = class PassportMiddleware {
    shouldSkip(ctx) {
        const request = ctx.getRequest();
        return request.user && request.isAuthenticated();
    }
    async use(ctx) {
        const endpoint = ctx.endpoint;
        const request = ctx.getRequest();
        if (this.shouldSkip(ctx)) {
            return;
        }
        const { options, protocol, method, originalUrl = true } = endpoint.store.get(PassportMiddleware_1);
        const protocols = getProtocolsFromRequest_1.getProtocolsFromRequest(request, protocol, this.protocolsService.getProtocolsNames());
        if (protocols.length === 0) {
            throw new exceptions_1.Unauthorized("Not authorized");
        }
        if (originalUrl) {
            request.url = request.originalUrl;
        }
        await this.call(method, protocols, options, ctx);
    }
    catchError(er) {
        if (!core_1.ancestorsOf(er).includes(Error)) {
            throw new PassportException_1.PassportException(er);
        }
        throw er;
    }
    async call(method, protocols, options, ctx) {
        const request = ctx.getRequest();
        const response = ctx.getResponse();
        try {
            options.failWithError = true;
            // @ts-ignore
            const middleware = passport_1.default[method](protocols.length === 1 ? protocols[0] : protocols, options);
            await new Promise((resolve, reject) => {
                middleware(request, response, (err) => {
                    err ? reject(err) : resolve();
                });
            });
        }
        catch (er) {
            this.catchError(er);
        }
    }
};
tslib_1.__decorate([
    common_1.Inject(ProtocolsService_1.ProtocolsService),
    tslib_1.__metadata("design:type", ProtocolsService_1.ProtocolsService)
], PassportMiddleware.prototype, "protocolsService", void 0);
tslib_1.__decorate([
    tslib_1.__param(0, common_1.Context()),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], PassportMiddleware.prototype, "use", null);
PassportMiddleware = PassportMiddleware_1 = tslib_1.__decorate([
    common_1.Middleware()
], PassportMiddleware);
exports.PassportMiddleware = PassportMiddleware;
//# sourceMappingURL=PassportMiddleware.js.map