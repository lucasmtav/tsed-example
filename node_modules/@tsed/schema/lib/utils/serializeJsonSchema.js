"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeJsonSchema = exports.serializeGenerics = exports.serializeAny = exports.serializeObject = exports.serializeMap = exports.serializeInherited = exports.serializeItem = exports.serializeClass = void 0;
const core_1 = require("@tsed/core");
const JsonAliasMap_1 = require("../domain/JsonAliasMap");
const SpecTypes_1 = require("../domain/SpecTypes");
const alterIgnore_1 = require("../hooks/alterIgnore");
const createRef_1 = require("./createRef");
const generics_1 = require("./generics");
const getInheritedStores_1 = require("./getInheritedStores");
const getJsonEntityStore_1 = require("./getJsonEntityStore");
const getRequiredProperties_1 = require("./getRequiredProperties");
/**
 * @ignore
 */
const IGNORES = ["name", "$required", "$hooks", "_nestedGenerics", SpecTypes_1.SpecTypes.OPENAPI, SpecTypes_1.SpecTypes.SWAGGER, SpecTypes_1.SpecTypes.JSON];
/**
 * @ignore
 */
const IGNORES_OPENSPEC = ["const"];
const IGNORES_OS2 = [, "writeOnly", "readOnly"];
/**
 * @ignore
 */
function isEmptyProperties(key, value) {
    return typeof value === "object" && ["items", "properties", "additionalProperties"].includes(key) && Object.keys(value).length === 0;
}
/**
 * @ignore
 */
function shouldMapAlias(key, value, useAlias) {
    return typeof value === "object" && useAlias && ["properties", "additionalProperties"].includes(key);
}
/**
 * @ignore
 */
function serializeClass(value, options = {}) {
    const store = getJsonEntityStore_1.getJsonEntityStore(value.class);
    const name = createRef_1.createRefName(store.schema.getName() || value.getName(), options);
    if (value.hasGenerics) {
        // Inline generic
        const { type, properties, additionalProperties, items, ...props } = value.toJSON(options);
        const schema = {
            ...serializeAny(store.schema, {
                ...options,
                ...generics_1.popGenerics(value),
                root: false
            }),
            ...props
        };
        if (schema.title) {
            const name = createRef_1.createRefName(schema.title, options);
            options.schemas[name] = schema;
            delete schema.title;
            return createRef_1.createRef(name, options);
        }
        return schema;
    }
    if (options.schemas && !options.schemas[name]) {
        options.schemas[name] = {}; // avoid infinite calls
        options.schemas[name] = serializeAny(store.schema, generics_1.mapGenericsOptions({
            ...options,
            root: false
        }));
    }
    return createRef_1.createRef(name, options);
}
exports.serializeClass = serializeClass;
function toRef(value, schema, options) {
    const name = createRef_1.createRefName(value.getName(), options);
    options.schemas[value.getName()] = schema;
    return createRef_1.createRef(name, options);
}
/**
 * @ignore
 */
function serializeItem(value, options) {
    return value && value.isClass ? serializeClass(value, options) : serializeAny(value, options);
}
exports.serializeItem = serializeItem;
/**
 * @ignore
 */
function serializeInherited(obj, target, options = {}) {
    const stores = Array.from(getInheritedStores_1.getInheritedStores(target).entries()).filter(([model]) => core_1.classOf(model) !== core_1.classOf(target));
    if (stores.length) {
        const schema = stores.reduce((obj, [, store]) => {
            return core_1.deepExtends(obj, serializeJsonSchema(store.schema, options));
        }, {});
        obj = core_1.deepExtends(schema, obj);
    }
    return obj;
}
exports.serializeInherited = serializeInherited;
/**
 * Serialize class which inherit from Map like JsonMap, JsonOperation, JsonParameter.
 * @param input
 * @param ignore
 * @param options
 * @ignore
 */
function serializeMap(input, { ignore = [], ...options } = {}) {
    options = generics_1.mapGenericsOptions(options);
    return Array.from(input.entries()).reduce((obj, [key, value]) => {
        if (ignore.includes(key)) {
            return obj;
        }
        obj[key] = serializeItem(value, options);
        return obj;
    }, {});
}
exports.serializeMap = serializeMap;
/**
 * Serialize Any object to a json schema
 * @param input
 * @param options
 * @ignore
 */
function serializeObject(input, options) {
    const { specType, operationIdFormatter, root, schemas, genericTypes, nestedGenerics, useAlias, genericLabels, ...ctx } = options;
    return Object.entries(input).reduce((obj, [key, value]) => {
        if (options.withIgnoredProps !== false && !alterIgnore_1.alterIgnore(value, ctx)) {
            obj[key] = serializeItem(value, options);
        }
        return obj;
    }, core_1.isArray(input) ? [] : {});
}
exports.serializeObject = serializeObject;
/**
 * @ignore
 */
function serializeAny(input, options = {}) {
    options.schemas = options.schemas || {};
    if (typeof input !== "object" || input === null) {
        return input;
    }
    if ("toJSON" in input) {
        const schema = input.toJSON(generics_1.mapGenericsOptions(options));
        return input.canRef ? toRef(input, schema, options) : schema;
    }
    return serializeObject(input, options);
}
exports.serializeAny = serializeAny;
/**
 * @ignore
 */
function serializeGenerics(obj, options) {
    const { generics } = options;
    if (generics && obj.$ref) {
        if (generics.has(obj.$ref)) {
            const model = {
                class: generics.get(obj.$ref)
            };
            if (options.nestedGenerics.length === 0) {
                return serializeClass(model, {
                    ...options,
                    generics: undefined
                });
            }
            const store = getJsonEntityStore_1.getJsonEntityStore(model.class);
            return serializeJsonSchema(store.schema, {
                ...options,
                ...generics_1.popGenerics(options),
                root: false
            });
        }
    }
    return obj;
}
exports.serializeGenerics = serializeGenerics;
function shouldSkipKey(key, { specType = SpecTypes_1.SpecTypes.JSON, customKeys = false }) {
    return (IGNORES.includes(key) ||
        (key.startsWith("#") && (customKeys === false || specType !== SpecTypes_1.SpecTypes.JSON)) ||
        (specType === SpecTypes_1.SpecTypes.SWAGGER && IGNORES_OS2.includes(key)) ||
        (specType !== SpecTypes_1.SpecTypes.JSON && IGNORES_OPENSPEC.includes(key)));
}
function transformTypes(obj) {
    const nullable = obj.type.includes("null") ? true : undefined;
    const types = obj.type.reduce((types, type) => {
        if (type !== "null") {
            return [...types, core_1.cleanObject({ type, nullable })];
        }
        return types;
    }, []);
    if (types.length > 1) {
        obj.oneOf = types;
    }
    else {
        obj.type = types[0].type;
        obj.nullable = types[0].nullable;
    }
    return obj;
}
/**
 * Convert JsonSchema instance to plain json object
 * @param schema
 * @param options
 * @ignore
 */
function serializeJsonSchema(schema, options = {}) {
    const { useAlias = true, schemas = {}, genericTypes } = options;
    let obj = [...schema.entries()].reduce((item, [key, value]) => {
        if (shouldSkipKey(key, options)) {
            return item;
        }
        key = key.replace(/^#/, "");
        if (key === "type") {
            value = schema.getJsonType();
        }
        if (key === "examples" && core_1.isObject(value) && [SpecTypes_1.SpecTypes.OPENAPI, SpecTypes_1.SpecTypes.SWAGGER].includes(options.specType)) {
            key = "example";
            value = Object.values(value)[0];
        }
        if (value) {
            if (value.isClass) {
                value = serializeClass(value, {
                    ...options,
                    useAlias,
                    schemas
                });
            }
            else {
                value = serializeAny(value, {
                    ...options,
                    useAlias,
                    schemas,
                    genericTypes,
                    genericLabels: schema.genericLabels
                });
            }
        }
        if (isEmptyProperties(key, value)) {
            return item;
        }
        if (shouldMapAlias(key, value, useAlias)) {
            value = JsonAliasMap_1.mapAliasedProperties(value, schema.alias);
        }
        item[key] = value;
        return item;
    }, {});
    if (schema.isClass) {
        obj = serializeInherited(obj, schema.getComputedType(), { ...options, root: false, schemas });
    }
    obj = serializeGenerics(obj, { ...options, root: false, schemas });
    if (schema.has(options.specType)) {
        obj = {
            ...obj,
            ...schema.get(options.specType).toJSON(options)
        };
    }
    obj = getRequiredProperties_1.getRequiredProperties(obj, schema, useAlias);
    if (options.specType === SpecTypes_1.SpecTypes.OPENAPI && core_1.isArray(obj.type)) {
        obj = transformTypes(obj);
    }
    if ((obj.oneOf || obj.allOf || obj.anyOf) && !(obj.items || obj.properties)) {
        delete obj.type;
    }
    return obj;
}
exports.serializeJsonSchema = serializeJsonSchema;
//# sourceMappingURL=serializeJsonSchema.js.map