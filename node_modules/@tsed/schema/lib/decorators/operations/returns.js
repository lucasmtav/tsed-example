"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Returns = void 0;
const core_1 = require("@tsed/core");
const httpStatusMessages_1 = require("../../constants/httpStatusMessages");
const DecoratorContext_1 = require("../../domain/DecoratorContext");
const JsonEntityStore_1 = require("../../domain/JsonEntityStore");
const JsonSchema_1 = require("../../domain/JsonSchema");
const defineStatusModel_1 = require("../../utils/defineStatusModel");
const isSuccessStatus_1 = require("../../utils/isSuccessStatus");
const mapHeaders_1 = require("../../utils/mapHeaders");
/**
 * @ignore
 */
class ReturnDecoratorContext extends DecoratorContext_1.DecoratorContext {
    constructor({ status, model }) {
        super();
        this.methods = [
            "contentType",
            "description",
            "examples",
            "type",
            "status",
            "of",
            "nested",
            "header",
            "headers",
            "schema",
            "title",
            "groups"
        ];
        this.set("status", status);
        this.set("model", model);
        if (status && httpStatusMessages_1.HTTP_STATUS_MESSAGES[status]) {
            this.set("description", httpStatusMessages_1.HTTP_STATUS_MESSAGES[status]);
            if (!model) {
                this.model(defineStatusModel_1.getStatusModel(+status));
            }
        }
    }
    type(model) {
        return this.model(model);
    }
    model(model) {
        this.set("model", model);
        return this;
    }
    status(status) {
        this.set("status", status);
        return this;
    }
    headers(headers) {
        this.set("headers", {
            ...(this.get("headers") || {}),
            ...mapHeaders_1.mapHeaders(headers)
        });
        return this;
    }
    header(key, value) {
        return this.headers({ [key]: value });
    }
    groups(...groups) {
        this.set("groups", groups);
        return this;
    }
    nested(...generics) {
        const model = this.get("model");
        this.checkPrimitive(model);
        this.checkCollection(model);
        this.addAction((ctx) => {
            this.get("schema").nestedGenerics.push(generics);
        });
        return this;
    }
    of(...types) {
        const model = this.get("model");
        this.checkPrimitive(model);
        this.addAction(() => {
            const schema = this.get("schema");
            if (core_1.isCollection(model)) {
                schema === null || schema === void 0 ? void 0 : schema.itemSchema({ type: types[0] });
            }
            else {
                schema === null || schema === void 0 ? void 0 : schema.nestedGenerics.push(types);
            }
        });
        return this;
    }
    schema(partial) {
        this.addAction(() => {
            const schema = this.get("schema");
            schema.assign(partial);
        });
        return this;
    }
    examples(examples) {
        this.set("examples", core_1.isString(examples) ? [examples] : examples);
        return this;
    }
    title(title) {
        return this.schema({ title });
    }
    checkPrimitive(model) {
        if (core_1.isPrimitiveOrPrimitiveClass(model)) {
            throw new Error("Returns.Of cannot be used with the following primitive classes: String, Number, Boolean");
        }
    }
    checkCollection(model) {
        if (core_1.isCollection(model)) {
            throw new Error("Returns.Nested cannot be used with the following classes: Map, Set, Array, String, Number, Boolean");
        }
    }
    getContentType() {
        const model = this.get("model");
        let contentType = this.get("contentType");
        if (model && !core_1.isPlainObject(model) && !core_1.isPrimitiveOrPrimitiveClass(model)) {
            contentType = contentType || "application/json";
        }
        return contentType;
    }
    getStatus() {
        return this.get("status") || "default";
    }
    onInit(args, decorator) {
        const type = core_1.decoratorTypeOf(args);
        switch (type) {
            case core_1.DecoratorTypes.METHOD:
                this.store = JsonEntityStore_1.JsonEntityStore.from(...args);
                if (this.store.operation) {
                    this.map();
                }
                break;
            case core_1.DecoratorTypes.CLASS:
                this.decoratorType = core_1.DecoratorTypes.CLASS;
                core_1.decorateMethodsOf(args[0], decorator);
                break;
            default:
                throw new core_1.UnsupportedDecoratorType(Returns, args);
        }
    }
    map() {
        const model = this.get("model");
        const { store, decoratorType } = this;
        const operation = this.store.operation;
        const currentStatus = this.getStatus();
        const response = operation.ensureResponseOf(currentStatus);
        const contentType = this.getContentType();
        let { description = response.get("description") } = this.toObject();
        if (description) {
            description = decoratorType === core_1.DecoratorTypes.CLASS ? response.get("description") || description : description;
            response.description(description);
        }
        const headers = this.getMergedKey("headers", response.get("headers"));
        if (headers) {
            response.headers(headers);
        }
        this.mapMedia(response);
        if (isSuccessStatus_1.isSuccessStatus(this.get("status")) || currentStatus === "default") {
            if (model) {
                store.type = model;
            }
        }
        // additional info for OS2
        contentType && operation.addProduce(contentType);
        // run additional actions
        return this.runActions();
    }
    mapMedia(response) {
        const contentType = this.getContentType();
        const model = this.get("model");
        const media = response.getMedia(contentType || "*/*");
        const schema = media.get("schema") || new JsonSchema_1.JsonSchema({ type: model });
        model && schema.type(model);
        this.set("schema", schema);
        media.schema(schema);
        media.groups = this.get("groups");
        const examples = this.get("examples");
        if (examples) {
            media.examples(examples);
        }
        return media;
    }
}
/**
 * @ignore
 */
function mapLegacy(decorator, model) {
    const { collectionType, type, headers, description, examples, schema } = model;
    if (collectionType || type) {
        decorator.Type(collectionType || type);
    }
    if (collectionType) {
        decorator = decorator.Of(type);
    }
    if (headers) {
        decorator = decorator.Headers(headers);
    }
    if (description) {
        decorator = decorator.Description(description);
    }
    if (examples) {
        decorator = decorator.Examples(examples);
    }
    if (schema) {
        decorator = decorator.Schema(schema);
    }
    return decorator;
}
function Returns(status, model) {
    if (model && core_1.isPlainObject(model)) {
        // istanbul ignore next
        if (!process.env.NODE_ENV || process.env.NODE_ENV === "development") {
            console.warn("Use @Returns/@Status with an object to describe schema is deprecated.");
            console.warn("Use the following example: @Returns(200, Type).Description('description')");
            console.warn('import {Returns} from "@tsed/schema"');
            console.warn("@Returns(200, Type).Description('description')");
        }
        const { code = "default" } = model;
        return mapLegacy(Returns(code), model);
    }
    const context = new ReturnDecoratorContext({
        status,
        model
    });
    return context.build();
}
exports.Returns = Returns;
//# sourceMappingURL=returns.js.map