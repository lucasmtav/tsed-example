"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PlatformControllerBuilder = void 0;
const schema_1 = require("@tsed/schema");
const ParamTypes_1 = require("../../mvc/models/ParamTypes");
const bindEndpointMiddleware_1 = require("../middlewares/bindEndpointMiddleware");
const PlatformAcceptMimesMiddleware_1 = require("../middlewares/PlatformAcceptMimesMiddleware");
const PlatformMulterMiddleware_1 = require("../middlewares/PlatformMulterMiddleware");
const PlatformRouter_1 = require("../services/PlatformRouter");
const useCtxHandler_1 = require("../utils/useCtxHandler");
/**
 * @ignore
 */
function formatMethod(method) {
    return (method === schema_1.OperationMethods.CUSTOM ? "use" : method || "use").toLowerCase();
}
/**
 * @ignore
 */
class PlatformControllerBuilder {
    constructor(provider) {
        this.provider = provider;
    }
    /**
     *
     * @returns {any}
     */
    build(injector) {
        const { routerOptions, middlewares: { useBefore } } = this.provider;
        this.provider.setRouter(PlatformRouter_1.PlatformRouter.create(injector, routerOptions));
        // Controller lifecycle
        this.buildMiddlewares(useBefore) // Controller before-middleware
            .buildEndpoints() // All endpoints and his middlewares
            .buildChildrenCtrls(injector); // Children controllers
        return this.provider.getRouter();
    }
    buildEndpoints() {
        const { endpoints } = this.provider;
        const operationPaths = new Map();
        const getKey = (method, path) => `${method}-${path}`;
        const updateFinalRouteState = (key) => {
            if (operationPaths.has(key)) {
                operationPaths.get(key).isFinal = false;
            }
        };
        const setFinalRoute = (key, operationPath) => {
            operationPaths.set(key, operationPath);
            operationPath.isFinal = true;
        };
        endpoints.forEach(({ operation }) => {
            operation === null || operation === void 0 ? void 0 : operation.operationPaths.forEach((operationPath) => {
                if (operationPath.method !== schema_1.OperationMethods.CUSTOM) {
                    const key = getKey(operationPath.method, operationPath.path);
                    updateFinalRouteState(key);
                    updateFinalRouteState(getKey(schema_1.OperationMethods.ALL, operationPath.path));
                    setFinalRoute(key, operationPath);
                }
            });
        });
        endpoints.forEach((endpoint) => {
            this.buildEndpoint(endpoint);
        });
        return this;
    }
    buildEndpoint(endpoint) {
        const { beforeMiddlewares, middlewares: mldwrs, afterMiddlewares, operation } = endpoint;
        const { middlewares: { use, useAfter } } = this.provider;
        const router = this.provider.getRouter();
        // Endpoint lifecycle
        let handlers = [];
        const hasFiles = [...endpoint.children.values()].find((item) => item.paramType === ParamTypes_1.ParamTypes.FILES);
        handlers = handlers
            .concat(useCtxHandler_1.useCtxHandler(bindEndpointMiddleware_1.bindEndpointMiddleware(endpoint)))
            .concat(PlatformAcceptMimesMiddleware_1.PlatformAcceptMimesMiddleware)
            .concat(hasFiles && PlatformMulterMiddleware_1.PlatformMulterMiddleware)
            .concat(use) // Controller use-middlewares
            .concat(beforeMiddlewares) // Endpoint before-middlewares
            .concat(mldwrs) // Endpoint middlewares
            .concat(endpoint) // Endpoint metadata
            .concat(afterMiddlewares) // Endpoint after-middlewares
            .concat(useAfter) // Controller after middlewares (equivalent to afterEach)
            .filter((item) => !!item);
        // Add handlers to the router
        operation === null || operation === void 0 ? void 0 : operation.operationPaths.forEach(({ path, method, isFinal }) => {
            router.addRoute({
                method: formatMethod(method),
                path,
                handlers,
                isFinal
            });
        });
        if (!(operation === null || operation === void 0 ? void 0 : operation.operationPaths.size)) {
            router.use(...handlers);
        }
    }
    buildChildrenCtrls(injector) {
        const { children } = this.provider;
        const router = this.provider.getRouter();
        children.forEach((child) => {
            const provider = injector.getProvider(child);
            /* istanbul ignore next */
            if (!provider) {
                throw new Error("Controller component not found in the ControllerRegistry");
            }
            new PlatformControllerBuilder(provider).build(injector);
            router.use(provider.path, provider.getRouter());
        });
    }
    buildMiddlewares(middlewares) {
        const router = this.provider.getRouter();
        middlewares
            .filter((o) => typeof o === "function")
            .forEach((middleware) => {
            router.use(middleware);
        });
        return this;
    }
}
exports.PlatformControllerBuilder = PlatformControllerBuilder;
//# sourceMappingURL=PlatformControllerBuilder.js.map