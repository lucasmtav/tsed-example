"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidationPipe = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const json_mapper_1 = require("@tsed/json-mapper");
const schema_1 = require("@tsed/schema");
const RequiredValidationError_1 = require("../errors/RequiredValidationError");
const ParamTypes_1 = require("../models/ParamTypes");
let ValidationPipe = class ValidationPipe {
    constructor(injector) {
        const provider = injector.getProviders().find((provider) => core_1.nameOf(provider.token) === "AjvService");
        if (provider) {
            this.validator = injector.invoke(provider.token);
        }
    }
    coerceTypes(value, metadata) {
        if (value === undefined) {
            return value;
        }
        if (value === "null") {
            return null;
        }
        if (metadata.isPrimitive) {
            try {
                return json_mapper_1.deserialize(value, {
                    type: metadata.type
                });
            }
            catch (er) {
                return value;
            }
        }
        if (metadata.isArray) {
            return [].concat(value);
        }
        return value;
    }
    skip(value, metadata) {
        return metadata.paramType === ParamTypes_1.ParamTypes.PATH && !metadata.isPrimitive;
    }
    async transform(value, metadata) {
        if (!this.validator) {
            this.checkIsRequired(value, metadata);
            return value;
        }
        if (this.skip(value, metadata)) {
            return value;
        }
        value = this.coerceTypes(value, metadata);
        this.checkIsRequired(value, metadata);
        if (value === undefined) {
            return value;
        }
        await this.validator.validate(value, {
            schema: schema_1.getJsonSchema(metadata, { groups: metadata.parameter.groups, customKeys: true }),
            type: metadata.isClass ? metadata.type : undefined,
            collectionType: metadata.collectionType
        });
        return value;
    }
    checkIsRequired(value, metadata) {
        if (metadata.isRequired(value)) {
            throw RequiredValidationError_1.RequiredValidationError.from(metadata);
        }
        return true;
    }
};
ValidationPipe = tslib_1.__decorate([
    di_1.Injectable({
        type: "validator"
    }),
    tslib_1.__metadata("design:paramtypes", [di_1.InjectorService])
], ValidationPipe);
exports.ValidationPipe = ValidationPipe;
//# sourceMappingURL=ValidationPipe.js.map