"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TestMongooseContext = void 0;
const common_1 = require("@tsed/common");
const mongoose_1 = require("@tsed/mongoose");
const mongodb_memory_server_1 = require("mongodb-memory-server");
const path_1 = require("path");
const downloadDir = path_1.resolve(`${require.resolve("mongodb-memory-server")}/../../.cache/mongodb-memory-server/mongodb-binaries`);
class TestMongooseContext extends common_1.PlatformTest {
    static getMongo() {
        // @ts-ignore
        return global.__MONGOD__;
    }
    static async install(options = { binary: {} }) {
        if (!TestMongooseContext.getMongo()) {
            // @ts-ignore
            global.__MONGOD__ = new mongodb_memory_server_1.MongoMemoryServer({
                ...options,
                binary: {
                    ...(options.binary || {}),
                    downloadDir
                }
            });
        }
        return TestMongooseContext.getMongooseOptions();
    }
    /**
     * Connect to the in-memory database.
     */
    static bootstrap(mod, options = {}) {
        return async function before() {
            const config = await TestMongooseContext.install(options.mongod);
            const mongod = TestMongooseContext.getMongo();
            // istanbul ignore next
            if (!mongod.runningInstance) {
                await mongod.start();
            }
            const before = common_1.PlatformTest.bootstrap(mod, {
                ...options,
                mongoose: config
            });
            await before();
        };
    }
    static async create(options = {}) {
        options.mongoose = await TestMongooseContext.install(options.mongod);
        return common_1.PlatformTest.create(options);
    }
    /**
     * Resets the test injector of the test context, so it won't pollute your next test. Call this in your `tearDown` logic.
     */
    static async reset() {
        await new Promise((resolve) => setTimeout(resolve, 100));
        await common_1.PlatformTest.reset();
        await TestMongooseContext.getMongo().stop();
    }
    /**
     *
     */
    static async clearDatabase() {
        const mongooseService = common_1.PlatformTest.get(mongoose_1.MongooseService);
        const promises = [];
        for (const connection of mongooseService.connections.values()) {
            promises.push(...Object.values(connection.collections).map((collection) => collection.deleteMany({})));
        }
        await Promise.all(promises);
    }
    static async getMongooseOptions() {
        const url = await TestMongooseContext.getMongo().getUri();
        return {
            url,
            connectionOptions: {
                useUnifiedTopology: true,
                useNewUrlParser: true
            }
        };
    }
}
exports.TestMongooseContext = TestMongooseContext;
//# sourceMappingURL=TestMongooseContext.js.map