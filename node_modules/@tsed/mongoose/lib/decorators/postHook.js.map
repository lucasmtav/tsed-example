{"version":3,"file":"postHook.js","sourceRoot":"","sources":["../../src/decorators/postHook.ts"],"names":[],"mappings":";;;AAAA,qCAAkF;AAElF,0DAAqD;AAgDrD,SAAgB,QAAQ,CAAU,MAAc,EAAE,GAAG,MAAa;IAChE,OAAO,CAAC,CAAC,GAAG,IAAW,EAAE,EAAE;QACzB,IAAI,OAAO,GAAwB,MAAM,CAAC,CAAC,CAAC,CAAC;QAC7C,IAAI,EAAE,GAA0B,MAAM,CAAC,CAAC,CAAC,CAAC;QAE1C,IAAI,sBAAe,CAAC,IAAI,CAAC,KAAK,qBAAc,CAAC,UAAU,EAAE;YACvD,OAAO,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YACpB,EAAE,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;SACrC;QAED,6BAAa,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;YACrB,IAAI,EAAE;gBACJ;oBACE,MAAM;oBACN,EAAE;oBACF,OAAO;iBACR;aACF;SACF,CAAC,CAAC;IACL,CAAC,CAAQ,CAAC;AACZ,CAAC;AApBD,4BAoBC","sourcesContent":["import {decoratorTypeOf, DecoratorTypes, StaticMethodDecorator} from \"@tsed/core\";\nimport {MongooseHookOptions, MongoosePostHookCB} from \"../interfaces\";\nimport {schemaOptions} from \"../utils/schemaOptions\";\n\n/**\n * We can simply attach a `@PostHook` decorator to your model class and\n * define the hook function like you normally would in Mongoose.\n *\n * ```typescript\n * import {Ignore, Required} from \"@tsed/common\";\n * import {PostHook, Model} from \"@tsed/mongoose\";\n *\n * @Model()\n * @PostHook(\"save\", (car: CarModel) => {\n *    if (car.topSpeedInKmH > 300) {\n *        console.log(car.model, 'is fast!');\n *    }\n * })\n * export class CarModel {\n *    @Ignore()\n *    _id: string;\n *\n *    @Required()\n *    model: string;\n *\n *    @Required()\n *    isFast: boolean;\n *\n *    // or Prehook on static method\n *    @PostHook(\"save\")\n *    static postSave(car: CarModel) {\n *       if (car.topSpeedInKmH > 300) {\n *           console.log(car.model, 'is fast!');\n *       }\n *    }\n * }\n * ```\n *\n * This will execute the post-save hook each time a `CarModel` document is saved.\n *\n * @param {string} method\n * @param fn\n * @returns {Function}\n * @decorator\n * @mongoose\n * @class\n */\nexport function PostHook<T = any>(method: string, fn: MongoosePostHookCB<T>): ClassDecorator;\nexport function PostHook<T = any>(method: string, fn: MongoosePostHookCB<T>, options: MongooseHookOptions): ClassDecorator;\nexport function PostHook<T = any>(method: string, options: MongooseHookOptions): StaticMethodDecorator;\nexport function PostHook<T = any>(method: string, ...params: any[]): Function {\n  return ((...args: any[]) => {\n    let options: MongooseHookOptions = params[1];\n    let fn: MongoosePostHookCB<T> = params[0];\n\n    if (decoratorTypeOf(args) === DecoratorTypes.METHOD_STC) {\n      options = params[0];\n      fn = args[0][args[1]].bind(args[0]);\n    }\n\n    schemaOptions(args[0], {\n      post: [\n        {\n          method,\n          fn,\n          options\n        }\n      ]\n    });\n  }) as any;\n}\n"]}