"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSchemaTypeOptions = exports.buildMongooseSchema = exports.getSchema = exports.createSchema = void 0;
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const json_mapper_1 = require("@tsed/json-mapper");
const schema_1 = require("@tsed/schema");
const mongoose_1 = tslib_1.__importDefault(require("mongoose"));
const constants_1 = require("../constants");
const resolveRefType_1 = require("./resolveRefType");
const schemaOptions_1 = require("./schemaOptions");
const MONGOOSE_RESERVED_KEYS = ["_id"];
/**
 * @ignore
 */
function setUpSchema({ schema, virtuals }, options) {
    const mongooseSchema = new mongoose_1.default.Schema(schema, options);
    for (const [key, options] of virtuals.entries()) {
        mongooseSchema.virtual(key, options);
    }
    return mongooseSchema;
}
/**
 * @ignore
 */
function isVirtualRef(target) {
    return !!(target.ref && target.localField && target.foreignField);
}
function createSchema(target, options = {}) {
    const schema = setUpSchema(buildMongooseSchema(target), options.schemaOptions);
    schemaOptions_1.schemaOptions(target, options);
    schema.methods.toClass = function toClass() {
        return json_mapper_1.deserialize(this.toObject({
            versionKey: false,
            flattenMaps: true
        }), {
            type: target,
            useAlias: false,
            additionalProperties: true,
            groups: false
        });
    };
    schema.methods.toJSON = function toJSON(options) {
        return json_mapper_1.serialize(this.toClass(), options);
    };
    schema.loadClass(target);
    return schema;
}
exports.createSchema = createSchema;
/**
 * Get a schema already created. If the schema doesn't exists in registry, it'll be created.
 * @param target
 * @param options
 */
function getSchema(target, options = {}) {
    const store = core_1.Store.from(target);
    if (!store.has(constants_1.MONGOOSE_SCHEMA)) {
        store.set(constants_1.MONGOOSE_SCHEMA, createSchema(target, options));
    }
    return store.get(constants_1.MONGOOSE_SCHEMA);
}
exports.getSchema = getSchema;
/**
 * @ignore
 */
function buildMongooseSchema(target) {
    const properties = schema_1.getProperties(target, { withIgnoredProps: true, mongoose: true, groups: false });
    const schema = { schema: {}, virtuals: new Map() };
    properties.forEach((propertyMetadata, key) => {
        if (MONGOOSE_RESERVED_KEYS.includes(key)) {
            return;
        }
        // Keeping the Mongoose Schema separate so it can overwrite everything once schema has been built.
        const schemaTypeOptions = propertyMetadata.store.get(constants_1.MONGOOSE_SCHEMA) || {};
        if (schemaTypeOptions.schemaIgnore) {
            return;
        }
        if (schemaTypeOptions.ref) {
            schemaTypeOptions.ref = resolveRefType_1.resolveRefType(schemaTypeOptions.ref);
        }
        if (isVirtualRef(schemaTypeOptions)) {
            schemaTypeOptions.justOne = !propertyMetadata.isArray;
            schema.virtuals.set(key, schemaTypeOptions);
            return;
        }
        schema.schema[key] = createSchemaTypeOptions(propertyMetadata);
    });
    return schema;
}
exports.buildMongooseSchema = buildMongooseSchema;
/**
 * @ignore
 */
function createSchemaTypeOptions(propEntity) {
    const key = propEntity.propertyKey;
    const rawMongooseSchema = propEntity.store.get(constants_1.MONGOOSE_SCHEMA) || {};
    let schemaTypeOptions = {
        required: propEntity.required
            ? function () {
                return propEntity.isRequired(this[key]);
            }
            : false
    };
    if (!propEntity.isClass) {
        const jsonSchema = propEntity.itemSchema.toJSON();
        const { minimum: min, maximum: max, minLength: minlength, maxLength: maxlength } = jsonSchema;
        let match = jsonSchema.pattern;
        if (match) {
            match = new RegExp(match);
        }
        schemaTypeOptions = {
            ...schemaTypeOptions,
            type: propEntity.type,
            match: match,
            min,
            max,
            minlength,
            maxlength,
            enum: jsonSchema["enum"],
            default: jsonSchema["default"]
        };
    }
    else if (!rawMongooseSchema.ref) {
        // References are handled by the final merge
        schemaTypeOptions = { ...schemaTypeOptions, type: getSchema(propEntity.type) };
    }
    schemaTypeOptions = core_1.cleanObject({ ...schemaTypeOptions, ...rawMongooseSchema });
    if (propEntity.isCollection) {
        if (propEntity.isArray) {
            return [schemaTypeOptions];
        }
        // Can be a Map or a Set;
        // Mongoose implements only Map;
        if (propEntity.collectionType !== Map) {
            throw new Error(`Invalid collection type. ${propEntity.collectionName} is not supported.`);
        }
        return { type: Map, of: schemaTypeOptions };
    }
    return schemaTypeOptions;
}
exports.createSchemaTypeOptions = createSchemaTypeOptions;
//# sourceMappingURL=createSchema.js.map