{"version":3,"file":"createSchema.js","sourceRoot":"","sources":["../../src/utils/createSchema.ts"],"names":[],"mappings":"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","sourcesContent":["import {cleanObject, Store, Type} from \"@tsed/core\";\nimport {deserialize, serialize} from \"@tsed/json-mapper\";\nimport {getProperties, JsonEntityStore} from \"@tsed/schema\";\nimport mongoose, {Schema, SchemaDefinition, SchemaOptions, SchemaTypeOptions} from \"mongoose\";\nimport {MONGOOSE_SCHEMA} from \"../constants\";\nimport {MongooseSchemaOptions} from \"../interfaces\";\nimport {MongooseVirtualRefOptions} from \"../interfaces/MongooseVirtualRefOptions\";\nimport {resolveRefType} from \"./resolveRefType\";\nimport {schemaOptions} from \"./schemaOptions\";\n\nconst MONGOOSE_RESERVED_KEYS = [\"_id\"];\n\nexport interface MongooseSchemaMetadata {\n  schema: SchemaDefinition;\n  virtuals: Map<string, MongooseVirtualRefOptions>;\n}\n\n/**\n * @ignore\n */\nfunction setUpSchema({schema, virtuals}: MongooseSchemaMetadata, options?: SchemaOptions) {\n  const mongooseSchema = new mongoose.Schema(schema, options);\n\n  for (const [key, options] of virtuals.entries()) {\n    mongooseSchema.virtual(key, options);\n  }\n\n  return mongooseSchema;\n}\n\n/**\n * @ignore\n */\nfunction isVirtualRef(target: Partial<MongooseVirtualRefOptions>): target is MongooseVirtualRefOptions {\n  return !!(target.ref && target.localField && target.foreignField);\n}\n\nexport function createSchema(target: Type<any>, options: MongooseSchemaOptions = {}): mongoose.Schema {\n  const schema = setUpSchema(buildMongooseSchema(target), options.schemaOptions);\n\n  schemaOptions(target, options);\n\n  schema.methods.toClass = function toClass() {\n    return deserialize(\n      this.toObject({\n        versionKey: false,\n        flattenMaps: true\n      }),\n      {\n        type: target,\n        useAlias: false,\n        additionalProperties: true,\n        groups: false\n      }\n    );\n  };\n\n  schema.methods.toJSON = function toJSON(options?: any) {\n    return serialize(this.toClass(), options);\n  };\n\n  schema.loadClass(target);\n\n  return schema;\n}\n\n/**\n * Get a schema already created. If the schema doesn't exists in registry, it'll be created.\n * @param target\n * @param options\n */\nexport function getSchema(target: Type<any>, options: MongooseSchemaOptions = {}): Schema {\n  const store = Store.from(target);\n\n  if (!store.has(MONGOOSE_SCHEMA)) {\n    store.set(MONGOOSE_SCHEMA, createSchema(target, options));\n  }\n\n  return store.get(MONGOOSE_SCHEMA);\n}\n\n/**\n * @ignore\n */\nexport function buildMongooseSchema(target: any): MongooseSchemaMetadata {\n  const properties = getProperties(target, {withIgnoredProps: true, mongoose: true, groups: false});\n  const schema: MongooseSchemaMetadata = {schema: {}, virtuals: new Map()};\n\n  properties.forEach((propertyMetadata, key) => {\n    if (MONGOOSE_RESERVED_KEYS.includes(key as string)) {\n      return;\n    }\n\n    // Keeping the Mongoose Schema separate so it can overwrite everything once schema has been built.\n    const schemaTypeOptions: any = propertyMetadata.store.get(MONGOOSE_SCHEMA) || {};\n\n    if (schemaTypeOptions.schemaIgnore) {\n      return;\n    }\n\n    if (schemaTypeOptions.ref) {\n      schemaTypeOptions.ref = resolveRefType(schemaTypeOptions.ref as any);\n    }\n\n    if (isVirtualRef(schemaTypeOptions)) {\n      schemaTypeOptions.justOne = !propertyMetadata.isArray;\n      schema.virtuals.set(key as string, schemaTypeOptions);\n\n      return;\n    }\n\n    schema.schema[key as string] = createSchemaTypeOptions(propertyMetadata);\n  });\n\n  return schema;\n}\n\n/**\n * @ignore\n */\nexport function createSchemaTypeOptions<T = any>(propEntity: JsonEntityStore): SchemaTypeOptions<T> | SchemaTypeOptions<T>[] {\n  const key = propEntity.propertyKey;\n  const rawMongooseSchema = propEntity.store.get(MONGOOSE_SCHEMA) || {};\n\n  let schemaTypeOptions: SchemaTypeOptions<T> = {\n    required: propEntity.required\n      ? function () {\n          return propEntity.isRequired(this[key]);\n        }\n      : false\n  };\n\n  if (!propEntity.isClass) {\n    const jsonSchema = propEntity.itemSchema.toJSON();\n    const {minimum: min, maximum: max, minLength: minlength, maxLength: maxlength} = jsonSchema;\n\n    let match: string | RegExp = jsonSchema.pattern;\n    if (match) {\n      match = new RegExp(match);\n    }\n\n    schemaTypeOptions = {\n      ...schemaTypeOptions,\n      type: propEntity.type,\n      match: match as RegExp,\n      min,\n      max,\n      minlength,\n      maxlength,\n      enum: jsonSchema[\"enum\"],\n      default: jsonSchema[\"default\"]\n    };\n  } else if (!rawMongooseSchema.ref) {\n    // References are handled by the final merge\n    schemaTypeOptions = {...schemaTypeOptions, type: getSchema(propEntity.type) as any};\n  }\n\n  schemaTypeOptions = cleanObject({...schemaTypeOptions, ...rawMongooseSchema});\n\n  if (propEntity.isCollection) {\n    if (propEntity.isArray) {\n      return [schemaTypeOptions];\n    }\n    // Can be a Map or a Set;\n    // Mongoose implements only Map;\n    if (propEntity.collectionType !== Map) {\n      throw new Error(`Invalid collection type. ${propEntity.collectionName} is not supported.`);\n    }\n\n    return ({type: Map, of: schemaTypeOptions} as unknown) as SchemaTypeOptions<T>;\n  }\n\n  return schemaTypeOptions;\n}\n"]}